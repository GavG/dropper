<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flowz</title>

    <style>
        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0px;
            overflow: hidden;
        }

        :root {
            --blockWidth: 5%;
            --blockHeight: 5%;
        }

        #board {
            height: calc(100% - var(--blockHeight));
            width: 100%;
            top: var(--blockHeight);
            ;
            background-color: aqua;
            position: absolute;
        }

        #dropper {
            top: 0%;
            left: 40%;
            background-color: purple;
            width: var(--blockWidth);
            height: var(--blockHeight);
            position: absolute;
            transition: all 0.3s ease 0s;
        }

        #dropper:after {
            content: '';
            position: absolute;
            z-index: 2;
            width: 300%;
            height: 100%;
            left: -100%;
            top: 50%;
            background-color: purple;
            border-top-left-radius: 50%;
            border-top-right-radius: 50%;
        }

        i {
            width: var(--blockWidth);
            height: var(--blockHeight);
            position: absolute;
            background-image: linear-gradient(0deg, #ffffff 25%, #ff4040 25%, #ff4040 50%, #ffffff 50%, #ffffff 75%, #ff4040 75%, #ff4040 100%);
            transition: all 0.3s ease 0s;
        }
    </style>

</head>

<body>

    <div id="dropper"></div>

    <div id="board"></div>

    <script>

        class Level {
            constructor(name, gameSpeed, blockMap) {
                this.name = name
                this.gameSpeed = gameSpeed
                this.blockMap = blockMap
            }

            start() {
                gameSpeed = this.gameSpeed
                console.log(this.name)
            }
        }

        class Block {
            constructor(x, y, index) {
                this.x = x
                this.y = y
                this.index = index
                this.createElement()
                this.locked = false
            }

            createElement() {
                this.element = document.createElement('i')
                this.updateStyle()
                board.append(this.element)
            }

            updateStyle() {
                this.element.style.left = this.x + '%'
                this.element.style.top = this.y + '%'
            }

            moveDown() {
                if (!this.locked) {
                    let nextY = this.y + blockHeight
                    if ((this.y < blockMaxPosY) && isFreeSpace(this.x, nextY)) {
                        this.y = nextY
                    } else {
                        this.locked = true
                    }
                }

                this.updateStyle()
            }
        }

        let board = document.getElementById('board')
        let dropper = document.getElementById('dropper')

        let blocks = []
        let gameOver = false
        let gameSpeed = 0
        let lastRender = 0
        let blockStartingX = 40
        let blockStartingY = 0
        let blockWidth = 5
        let blockHeight = 5
        let blockMaxPosY = 100 - blockHeight
        let blockMinPosX = 0
        let blockMaxPosX = 100 - blockWidth

        let levels = [
            new Level('Flat Land', 350, [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            ])
        ]

        function addBlock() {
            if (isFreeSpace(blockStartingX, blockStartingY, this.index)) {
                return blocks.push(new Block(blockStartingX, blockStartingY, blocks.length))
            }
            gameOver = true
        }

        function isFreeSpace(x, y, index = 0) {
            return !blocks.slice(index, blocks.length).find(block => ((block.x === x) && (block.y === y)))
        }

        function nextFrame(progress) {
            blocks.forEach((block, index) => {
                block.moveDown()
            })
            addBlock()
            moved = false
        }

        function loop(timestamp) {
            var progress = timestamp - lastRender

            if (progress >= gameSpeed) {
                nextFrame(progress)
                lastRender = timestamp
            }

            if (gameOver) return alert('GAME OVER')

            window.requestAnimationFrame(loop)
        }

        window.addEventListener('keydown', function (e) {
            if (moved) return false
            switch (e.keyCode) {
                case 37:
                    (() => {
                        let newStartingX = blockStartingX - blockWidth
                        if (newStartingX >= blockMinPosX) {
                            blockStartingX = newStartingX
                            dropper.style.left = blockStartingX + '%'
                        }
                    })()
                    moved = true
                    break

                case 39:
                    (() => {
                        let newStartingX = blockStartingX + blockWidth
                        if (newStartingX <= blockMaxPosX) {
                            blockStartingX = newStartingX
                            dropper.style.left = blockStartingX + '%'
                        }
                    })()
                    moved = true
                    break
            }
        })

        levels[0].start()

        window.requestAnimationFrame(loop)

        addBlock()

    </script>

</body>

</html>